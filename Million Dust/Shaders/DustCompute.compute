
#pragma kernel Populate
#pragma kernel Update
#pragma kernel Blow

/*************************************************
 *                 Naming Conventions
 *************************************************
 - AToB  : B - A
 - ~Dir  : 방향 벡터(크기 1)
 - ~Dist : 두 위치 벡터 사이의 거리(스칼라)
 - ~Len  : 한 벡터의 길이
************************************************ */

#define TRUE 1
#define FALSE 0
#define TAU 6.28318530

struct Dust
{
    float3 position;
    int isAlive;
};

/*************************************************
/*                     Variables
/*************************************************/
RWStructuredBuffer<Dust> dustBuffer;        // 먼지 위치, 생존 여부
RWStructuredBuffer<float3> velocityBuffer;  // 먼지 속도
RWStructuredBuffer<uint> aliveNumberBuffer; // 생존한 먼지 개수

int isRunning;    // 청소기 가동 여부
float deltaTime;

float3 boundsMin; // 먼지 생성 영역 - 최소 지점
float3 boundsMax; // 먼지 생성 영역 - 최대 지점

float3 headPos;      // 진공 청소기 입구 위치
float sqrRange;      // 먼지 흡입 범위(반지름) - 제곱
float sqrDeathRange; // 먼지 소멸 범위(반지름) - 제곱
float sqrForce;      // 빨아들이는 힘 - 제곱

float3 headForwardDir; // 진공 청소기 전방 벡터
float dotThreshold;    // 진공 청소기 원뿔 영역 내적 범위

float radius;        // 먼지 반지름
float mass;          // 질량
float gravityForce;  // -Y 방향 중력 강도
float airResistance; // 공기 저항력

/*************************************************
/*                     Methods
/*************************************************/

#define RM 39482.17593
#define RD1 7.8671
#define RD2 3.3419
#define RD3 5.8912
#define RP1 2.1759
#define RP2 4.7921

float Random11(float seed)
{
    return frac(sin(dot(float2(RD1, seed), float2(seed, RD2))) * RM);
}
float2 Random12(float seed)
{
    return float2(
        frac(sin(dot(float2(RD1, seed), float2(seed, RD2))) * RM),
        frac(sin(dot(float2(seed, RD2), float2(RD3, seed))) * RM)
    );
}
float3 Random13(float seed)
{
    return float3(
        frac(sin(dot(float2(seed, RD1), float2(RD2, seed))) * RM),
        frac(sin(dot(float2(seed, RD2), float2(RD3, seed))) * RM),
        frac(sin(dot(float2(seed, RD3), float2(RD1, seed))) * RM)
    );
}

float RandomRange11(float seed, float min, float max)
{
    return lerp(min, max, Random11(seed)); 
}
float2 RandomRange12(float seed, float2 min, float2 max)
{
    float2 vec;
    vec.x = RandomRange11(seed,       min.x, max.x);
    vec.y = RandomRange11(seed + RP1, min.y, max.y);
    return vec;
}
float3 RandomRange13(float seed, float3 min, float3 max)
{
    float3 vec;
    vec.x = RandomRange11(seed,       min.x, max.x);
    vec.y = RandomRange11(seed + RP1, min.y, max.y);
    vec.z = RandomRange11(seed + RP2, min.z, max.z);
    return vec;
}

float Random21(float2 seed)
{
    return frac(sin(dot(seed, float2(RD1, RD2))) * RM);
}
float2 Random22(float2 seed)
{
    return float2(
        frac(sin(dot(seed,                    float2(RD1, RD2))) * RM),
        frac(sin(dot(seed + float2(RP1, RP2), float2(RD2, RD3))) * RM)
    );
}
float3 Random23(float2 seed)
{
    return float3(
        frac(sin(dot(seed,                    float2(RD1, RD2))) * RM),
        frac(sin(dot(seed + float2(RP1, RP2), float2(RD2, RD3))) * RM),
        frac(sin(dot(seed + float2(RP2, RP1), float2(RD3, RD1))) * RM)
    );
}

float RandomRange21(float2 seed, float min, float max)
{
    return lerp(min, max, Random21(seed)); 
}
float2 RandomRange22(float2 seed, float2 min, float2 max)
{
    float2 vec;
    vec.x = RandomRange21(seed,                    min.x, max.x);
    vec.y = RandomRange21(seed + float2(RP1, RP2), min.y, max.y);
    return vec;
}
float3 RandomRange23(float2 seed, float3 min, float3 max)
{
    float3 vec;
    vec.x = RandomRange21(seed,                    min.x, max.x);
    vec.y = RandomRange21(seed + float2(RP1, RP2), min.y, max.y);
    vec.z = RandomRange21(seed + float2(RP2, RP1), min.z, max.z);
    return vec;
}

float SqrMagnitude(float3 vec)
{
    return (vec.x * vec.x) + (vec.y * vec.y) + (vec.z * vec.z);
}

// 먼지 파괴
void DestroyDust(uint i)
{
    dustBuffer[i].isAlive = FALSE;
    InterlockedAdd(aliveNumberBuffer[0], -1);
}

// 구체 충돌 검사
bool CheckSphereToSphereCollision(float3 pos, float radius, float3 spherePos, float sphereRadius)
{
    return length(pos - spherePos) < (radius + sphereRadius);
}

/*************************************************
/*                     Kernels
/*************************************************/

// 0 - 초기 생성
[numthreads(64,1,1)]
void Populate (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;

    float width = boundsMax.x - boundsMin.x;
    float seed = i / (width * width * 179.823);
    
    dustBuffer[i].position = RandomRange13(seed, boundsMin, boundsMax);
    dustBuffer[i].isAlive = TRUE;
}

// 1 - 실시간 업데이트
[numthreads(64,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == FALSE) return;

    bool sucking = false;
    float3 F = 0; // 힘 합 벡터
    float3 A = 0; // 가속도 합 벡터
    
    // ===================================================
    //                  청소기로 먼지 흡수
    // ===================================================
    float3 currPos = dustBuffer[i].position;  // 현재 프레임 먼지 위치
    float3 currToHead = (headPos - currPos);  // 청소기 입구 -> 먼지
    float sqrDist = SqrMagnitude(currToHead); // 청소기 입구 <-> 먼지 사이 거리 제곱

    // 먼지 이동
    if (isRunning == TRUE && sqrDist < sqrRange)
    {
        float3 dustToHeadDir = normalize(currToHead); // 먼지 -> 청소기 입구 방향
        float dotValue = dot(headForwardDir, -dustToHeadDir);

        // 원뿔 범위 내에 있을 경우 빨아들이기
        if(dotValue > dotThreshold)
        {
            float suctionForce = sqrForce / sqrDist;

            // 빨아들이는 힘
            F += dustToHeadDir * suctionForce * dotValue;

            sucking = true;
        }
    }
    
    // F = m * a
    // v = a * t

    // ===================================================
    //                    가속도 계산
    // ===================================================
    // [1] 외력
    A += F / mass;

    // [2] 중력
    A += float3(0, -gravityForce, 0);

    // [3] 공기 저항
    A -= velocityBuffer[i] * airResistance;

    // 속도 적용 : V = A * t
    velocityBuffer[i] += A * deltaTime;
    
    // ===================================================
    //              이동 시뮬레이션, 충돌 검사
    // ===================================================
    // 다음 프레임 위치 계산 : S = S0 + V * t
    float3 nextPos = currPos + velocityBuffer[i] * deltaTime;

    // [1] Plane (Y = 0)
    nextPos.y = max(radius, nextPos.y);

    // [2] Sphere to Sphere
    //float3 spherePos = float3(0, 2.5, 0);
    //float3 sphereRadius = 5;
    //bool sphereCollided = CheckSphereToSphereCollision(nextPos, radius, spherePos, sphereRadius);
    //if(sphereCollided)
    //{
    //    float3 inDir = normalize(velocityBuffer[i]);
    //    float3 contactNormal = normalize(nextPos - spherePos);
    //    float3 adjNextPos = spherePos + contactNormal * (sphereRadius + radius);
    //    float3 outDir = reflect(inDir, contactNormal);
    //
    //    nextPos = adjNextPos;
    //    velocityBuffer[i] = outDir * length(velocityBuffer[i]) * 0.8;
    //}

    // [3] 입구로 완전히 빨아들인 경우, 먼지 파괴
    if(sucking)
    {
        float3 headToNext = nextPos - headPos;

        float3 headToCurrDir = normalize(-currToHead);
        float3 headToNextDir = normalize(headToNext);

        // 현재 프레임에 먼지가 원뿔 범위 내에 있었다면
        if(dot(headForwardDir, headToCurrDir) > dotThreshold)
        {
            // 다음 프레임에 원뿔 밖으로 나가거나 입구에 근접하면 파괴
            if(dot(headForwardDir, headToNextDir) < dotThreshold ||
               SqrMagnitude(headToNext) < sqrDeathRange)
            {
                DestroyDust(i);
            }
        }
    }
    
    // 다음 위치 적용
    dustBuffer[i].position = nextPos;
}

int maxNumber;       // 먼지 개수
float time;          // Time.time
float blowForce;     // 발사 강도(suctionForce 필드값)
float blowAngleRad;  // 발사 각도(suctionAngle 필드값)
float4x4 headMatrix; // CleanerHead : localToWorld

// 2 - 죽었던 먼지들 살려서 발사
[numthreads(64,1,1)]
void Blow (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == TRUE) return;
    if(i >= maxNumber) return;

    // 발사 확률 계산
    float seed = (i + time) / 79238.288;
    float r = Random11(seed);
    if(r > 0.01) return;

    // Note : localDir의 z를 1로 고정하고, xy를 tan(blowAngleRad)로 지정함으로써
    // 발사되는 먼지들이 형성하는 원뿔의 각도를 suctionAngle로 설정하는 효과를 얻는다.
    
    // r2.x : 각 먼지의 각도 (-360 ~ 360), r2.y : 원의 반지름(원뿔의 각도 결정)
    float seed2 = i / 82801.277;
    float2 r2 = RandomRange12(seed2, float2(-TAU, 0), float2(TAU, 1));
    float2 randomCircle = float2(cos(r2.x), sin(r2.x)) * r2.y * tan(blowAngleRad);

    float3 localDir = float3(randomCircle.x, randomCircle.y, 1);
    float3 worldDir = mul(headMatrix, localDir);
    
    dustBuffer[i].position = headPos;
    velocityBuffer[i] = (worldDir) * blowForce;

    // 먼지 되살리기
    dustBuffer[i].isAlive = TRUE;
    InterlockedAdd(aliveNumberBuffer[0], 1);
}