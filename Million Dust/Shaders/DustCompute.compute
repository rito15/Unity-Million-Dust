
#pragma kernel Populate
#pragma kernel Update
#pragma kernel Blow

#include "Type Definitions.cginc"
#include "Math Functions.cginc"
#include "Random Functions.cginc"
#include "Physics Functions.cginc"

/*******************************************************************
 *                        Naming Conventions
/*******************************************************************
 - AToB  : B - A
 - ~Dir  : 방향 벡터(크기 1)
 - ~Dist : 두 위치 벡터 사이의 거리(스칼라)
 - ~Len  : 한 벡터의 길이
/*******************************************************************/

/*******************************************************************
/*                            Definitions
/*******************************************************************/
#define TRUE 1
#define FALSE 0
#define TAU 6.28318530

/*******************************************************************
/*                            Constants
/*******************************************************************/

/*******************************************************************
/*                            Variables
/*******************************************************************/
RWStructuredBuffer<Dust> dustBuffer;        // 먼지 위치, 생존 여부
RWStructuredBuffer<float3> velocityBuffer;  // 먼지 속도
RWStructuredBuffer<uint> aliveNumberBuffer; // 생존한 먼지 개수

/* Common */
float3 boundsMin; // 먼지 생성 영역 - 최소 지점
float3 boundsMax; // 먼지 생성 영역 - 최대 지점
float deltaTime;

/* Controller */
float3 controllerPos;     // 월드 위치
float3 controllerForward; // 전방 벡터

/* Vacuum Cleaner */
int cleanerRunning;         // 청소기 가동 여부
float cleanerSqrDist;       // 먼지 흡입 범위(반지름) - 제곱
float cleanerSqrDeathRange; // 먼지 소멸 범위(반지름) - 제곱
float cleanerSqrForce;      // 빨아들이는 힘 - 제곱
float cleanerDotThreshold;  // 진공 청소기 원뿔 영역 내적 범위

/* Emitter */
uint dustCount;        // 먼지 개수
float time;            // Time.time
float emitterForce;    // 방출 강도
float emitterAngleRad; // 방출 각도
float4x4 controllerMatrix; //  localToWorld

/* Physics(Update) */
float radius;        // 먼지 반지름
float mass;          // 질량
float gravityForce;  // -Y 방향 중력 강도
float airResistance; // 공기 저항력
float elasticity;    // 탄성력

/*******************************************************************
/*                            Functions
/*******************************************************************/
// 먼지 파괴
void DestroyDust(uint i)
{
    dustBuffer[i].isAlive = FALSE;
    InterlockedAdd(aliveNumberBuffer[0], -1);
}

/*******************************************************************
/*                             Kernels
/*******************************************************************/
// 0 - 초기 생성
[numthreads(64,1,1)]
void Populate (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    
    float width = boundsMax.x - boundsMin.x;
    float seed = i / (width * width * 179.823);

    dustBuffer[i].position = RandomRange13(seed, boundsMin, boundsMax);
    dustBuffer[i].isAlive = TRUE;
}

// 1 - 실시간 업데이트
[numthreads(64,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == FALSE) return;

    bool sucking = false;
    float3 F = 0; // 힘 합 벡터
    float3 A = 0; // 가속도 합 벡터
    
    // ===================================================
    //                  청소기로 먼지 흡수
    // ===================================================
    float3 currPos = dustBuffer[i].position;  // 현재 프레임 먼지 위치
    float3 currToHead = (controllerPos - currPos);  // 청소기 입구 -> 먼지
    float sqrDist = SqrMagnitude(currToHead); // 청소기 입구 <-> 먼지 사이 거리 제곱

    // 먼지 이동
    if (cleanerRunning == TRUE && sqrDist < cleanerSqrDist)
    {
        float3 dustToHeadDir = normalize(currToHead); // 먼지 -> 청소기 입구 방향
        float dotValue = dot(controllerForward, -dustToHeadDir);

        // 원뿔 범위 내에 있을 경우 빨아들이기
        if(dotValue > cleanerDotThreshold)
        {
            float suctionForce = cleanerSqrForce / sqrDist;

            // 빨아들이는 힘
            F += dustToHeadDir * suctionForce * dotValue;

            sucking = true;
        }
    }
    
    // F = m * a
    // v = a * t

    // ===================================================
    //                    가속도 계산
    // ===================================================
    // [1] 외력
    A += F / mass;

    // [2] 중력
    A += float3(0, -gravityForce, 0);

    // [3] 공기 저항
    A -= velocityBuffer[i] * airResistance;

    // 속도 적용 : V = A * t
    velocityBuffer[i] += A * deltaTime;
    
    // ===================================================
    //              이동 시뮬레이션, 충돌 검사
    // ===================================================
    // 다음 프레임 위치 계산 : S = S0 + V * t
    float3 nextPos = currPos + velocityBuffer[i] * deltaTime;

    // [1] Cube 영역 제한
    Bounds bounds;
    bounds.min = boundsMin;
    bounds.max = boundsMax;
    ConfineWithinCubeBounds(currPos, nextPos, velocityBuffer[i], radius, elasticity, bounds);

    // [2] Sphere to Sphere
    //float3 spherePos = float3(0, 2.5, 0);
    //float3 sphereRadius = 5;
    //bool sphereCollided = CheckSphereToSphereCollision(nextPos, radius, spherePos, sphereRadius);
    //if(sphereCollided)
    //{
    //    float3 inDir = normalize(velocityBuffer[i]);
    //    float3 contactNormal = normalize(nextPos - spherePos);
    //    float3 adjNextPos = spherePos + contactNormal * (sphereRadius + radius);
    //    float3 outDir = reflect(inDir, contactNormal);
    //
    //    nextPos = adjNextPos;
    //    velocityBuffer[i] = outDir * length(velocityBuffer[i]) * 0.8;
    //}

    // [3] 입구로 완전히 빨아들인 경우, 먼지 파괴
    if(sucking)
    {
        float3 headToNext = nextPos - controllerPos;

        float3 headToCurrDir = normalize(-currToHead);
        float3 headToNextDir = normalize(headToNext);

        // 현재 프레임에 먼지가 원뿔 범위 내에 있었다면
        if(dot(controllerForward, headToCurrDir) > cleanerDotThreshold)
        {
            // 다음 프레임에 원뿔 밖으로 나가거나 입구에 근접하면 파괴
            if(dot(controllerForward, headToNextDir) < cleanerDotThreshold ||
               SqrMagnitude(headToNext) < cleanerSqrDeathRange)
            {
                DestroyDust(i);
            }
        }
    }
    
    // 다음 위치 적용
    dustBuffer[i].position = nextPos;
}

// 2 - 죽었던 먼지들 살려서 발사
[numthreads(64,1,1)]
void Blow (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == TRUE) return;
    if(i >= dustCount) return;

    // 발사 확률 계산
    float seed = (i + time) / 79238.288;
    float r = Random11(seed);
    if(r > 0.01) return;

    // Note : localDir의 z를 1로 고정하고, xy를 tan(emitterAngleRad)로 지정함으로써
    // 발사되는 먼지들이 형성하는 원뿔의 각도를 suctionAngle로 설정하는 효과를 얻는다.
    
    // r2.x : 각 먼지의 각도 (-360 ~ 360), r2.y : 원의 반지름(원뿔의 각도 결정)
    float seed2 = i / 82801.277;
    float2 r2 = RandomRange12(seed2, float2(-TAU, 0), float2(TAU, 1));
    float2 randomCircle = float2(cos(r2.x), sin(r2.x)) * r2.y * tan(emitterAngleRad);
    
    // 발사 방향 벡터 공간 변환
    float3 localDir = float3(randomCircle.x, randomCircle.y, 1);
    float3 worldDir = mul(controllerMatrix, float4(localDir, 0)).xyz;
    
    dustBuffer[i].position = controllerPos;        // 청소기 입구로 위치 이동
    velocityBuffer[i] = (worldDir) * emitterForce; // 발사 방향 설정

    // 먼지 되살리기
    dustBuffer[i].isAlive = TRUE;
    InterlockedAdd(aliveNumberBuffer[0], 1);
}