
#pragma kernel Populate
#pragma kernel Update
#pragma kernel Blow

/*************************************************
 *                 Naming Conventions
 *************************************************
 - AToB  : B - A
 - ~Dir  : 방향 벡터(크기 1)
 - ~Dist : 두 위치 벡터 사이의 거리(스칼라)
 - ~Len  : 한 벡터의 길이
************************************************ */

#define TRUE 1
#define FALSE 0

struct Dust
{
    float3 position;
    int isAlive;
};

/*************************************************
/*                     Variables
/*************************************************/
RWStructuredBuffer<Dust> dustBuffer;        // 먼지 위치, 생존 여부
RWStructuredBuffer<float3> velocityBuffer;  // 먼지 속도
RWStructuredBuffer<uint> aliveNumberBuffer; // 생존한 먼지 개수

int isRunning;    // 청소기 가동 여부
float deltaTime;

float3 boundsMin; // 먼지 생성 영역 - 최소 지점
float3 boundsMax; // 먼지 생성 영역 - 최대 지점

float3 headPos;      // 진공 청소기 입구 위치
float sqrRange;      // 먼지 흡입 범위(반지름) - 제곱
float sqrDeathRange; // 먼지 소멸 범위(반지름) - 제곱
float sqrForce;      // 빨아들이는 힘 - 제곱

float3 headForwardDir; // 진공 청소기 전방 벡터
float dotThreshold;    // 진공 청소기 원뿔 영역 내적 범위

float radius;        // 먼지 반지름
float mass;          // 질량
float gravityForce;  // -Y 방향 중력 강도
float airResistance; // 공기 저항력

/*************************************************
/*                     Methods
/*************************************************/
float Random(float2 seed)
{
    return frac(sin(dot(seed, float2(73.867, 25.241))) * 39482.17593);
}
float RandomRange(float2 seed, float min, float max)
{
    return lerp(min, max, Random(seed)); 
}
float3 RandomRange3(float2 seed, float3 min, float3 max)
{
    float3 vec;
    vec.x = RandomRange(seed, min.x, max.x);
    vec.y = RandomRange(seed + 7.219, min.y, max.y);
    vec.z = RandomRange(seed + 79.714, min.z, max.z);
    return vec;
}

float SqrMagnitude(float3 vec)
{
    return (vec.x * vec.x) + (vec.y * vec.y) + (vec.z * vec.z);
}

// 먼지 파괴
void DestroyDust(uint i)
{
    dustBuffer[i].isAlive = FALSE;
    InterlockedAdd(aliveNumberBuffer[0], -1);
}

// 구체 충돌 검사
bool CheckSphereToSphereCollision(float3 pos, float radius, float3 spherePos, float sphereRadius)
{
    return length(pos - spherePos) < (radius + sphereRadius);
}

/*************************************************
/*                     Kernels
/*************************************************/

// 0 - 초기 생성
[numthreads(64,1,1)]
void Populate (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;

    float width = boundsMax.x - boundsMin.x;
    float f = float(i);
    float2 uv = float2(f % width, f / width) / width;
    
    dustBuffer[i].position = RandomRange3(uv, boundsMin, boundsMax);
    dustBuffer[i].isAlive = TRUE;
}

// 1 - 실시간 업데이트
[numthreads(64,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == FALSE) return;

    bool sucking = false;
    float3 F = 0; // 힘 합 벡터
    float3 A = 0; // 가속도 합 벡터
    
    // ===================================================
    //                  청소기로 먼지 흡수
    // ===================================================
    float3 currPos = dustBuffer[i].position;  // 현재 프레임 먼지 위치
    float3 currToHead = (headPos - currPos);  // 청소기 입구 -> 먼지
    float sqrDist = SqrMagnitude(currToHead); // 청소기 입구 <-> 먼지 사이 거리 제곱

    // 먼지 이동
    if (isRunning == TRUE && sqrDist < sqrRange)
    {
        float3 dustToHeadDir = normalize(currToHead); // 먼지 -> 청소기 입구 방향
        float dotValue = dot(headForwardDir, -dustToHeadDir);

        // 원뿔 범위 내에 있을 경우 빨아들이기
        if(dotValue > dotThreshold)
        {
            float suctionForce = sqrForce / sqrDist;

            // 빨아들이는 힘
            F += dustToHeadDir * suctionForce * dotValue;

            sucking = true;
        }
    }
    
    // F = m * a
    // v = a * t

    // ===================================================
    //                    가속도 계산
    // ===================================================
    // [1] 외력
    A += F / mass;

    // [2] 중력
    A += float3(0, -gravityForce, 0);

    // [3] 공기 저항
    A -= velocityBuffer[i] * airResistance;

    // 속도 적용 : V = A * t
    velocityBuffer[i] += A * deltaTime;
    
    // ===================================================
    //              이동 시뮬레이션, 충돌 검사
    // ===================================================
    // 다음 프레임 위치 계산 : S = S0 + V * t
    float3 nextPos = currPos + velocityBuffer[i] * deltaTime;

    // [1] Plane (Y = 0)
    nextPos.y = max(radius, nextPos.y);

    // [2] Sphere to Sphere
    //float3 spherePos = float3(0, 2.5, 0);
    //float3 sphereRadius = 5;
    //bool sphereCollided = CheckSphereToSphereCollision(nextPos, radius, spherePos, sphereRadius);
    //if(sphereCollided)
    //{
    //    float3 inDir = normalize(velocityBuffer[i]);
    //    float3 contactNormal = normalize(nextPos - spherePos);
    //    float3 adjNextPos = spherePos + contactNormal * (sphereRadius + radius);
    //    float3 outDir = reflect(inDir, contactNormal);
    //
    //    nextPos = adjNextPos;
    //    velocityBuffer[i] = outDir * length(velocityBuffer[i]) * 0.8;
    //}

    // [3] 입구로 완전히 빨아들인 경우, 먼지 파괴
    if(sucking)
    {
        float3 headToNext = nextPos - headPos;

        float3 headToCurrDir = normalize(-currToHead);
        float3 headToNextDir = normalize(headToNext);

        // 현재 프레임에 먼지가 원뿔 범위 내에 있었다면
        if(dot(headForwardDir, headToCurrDir) > dotThreshold)
        {
            // 다음 프레임에 원뿔 밖으로 나가거나 입구에 근접하면 파괴
            if(dot(headForwardDir, headToNextDir) < dotThreshold ||
               SqrMagnitude(headToNext) < sqrDeathRange)
            {
                DestroyDust(i);
            }
        }
    }
    
    // 다음 위치 적용
    dustBuffer[i].position = nextPos;
}

int maxNumber;
float randomSeed;
float blowForce;
float4x4 headMatrix;

// 2 - 죽었던 먼지들 살려서 발사
[numthreads(64,1,1)]
void Blow (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == TRUE) return;
    if(i >= maxNumber) return;

    // 확률 계산
    float k = i + randomSeed;
    float2 seed = float2(k % 64, k / 64) / 64;
    float r = Random(seed);
    if(r > 0.01) return;

    // 스프레이.. 제대로 구현....

    float3 randomDir = RandomRange3(seed, -1, 1);

    float3 localDir = normalize(randomDir) * 0.5 + float3(0, 0, 1);
    float3 worldDir = mul(headMatrix, localDir);
    
    dustBuffer[i].position = headPos;
    velocityBuffer[i] = (worldDir) * blowForce;

    // 먼지 개수 추가
    dustBuffer[i].isAlive = TRUE;
    InterlockedAdd(aliveNumberBuffer[0], 1);
}