
#pragma kernel Populate
#pragma kernel Update
#pragma kernel VacuumUp
#pragma kernel Emit
#pragma kernel BlowWind

#include "Type Definitions.cginc"
#include "Math Functions.cginc"
#include "Random Functions.cginc"
#include "Physics Functions.cginc"

/*******************************************************************
 *                        Naming Conventions
/*******************************************************************
 - AToB  : B - A
 - ~Dir  : 방향 벡터(크기 1)
 - ~Dist : 두 위치 벡터 사이의 거리(스칼라)
 - ~Len  : 한 벡터의 길이
/*******************************************************************/

/*******************************************************************
/*                            Definitions
/*******************************************************************/
#define TRUE 1
#define FALSE 0
#define TAU 6.28318530
#define NUM_THREADS_HEADER numthreads(64,1,1)

/*******************************************************************
/*                            Variables
/*******************************************************************/
RWStructuredBuffer<Dust> dustBuffer;        // 먼지 위치, 생존 여부
RWStructuredBuffer<float3> velocityBuffer;  // 먼지 속도
RWStructuredBuffer<uint> aliveNumberBuffer; // 생존한 먼지 개수

/* Init On Load */
uint dustCount;        // 먼지 개수

/* Common */
float3 spawnBoundsMin; // 먼지 생성 영역 - 최소 지점
float3 spawnBoundsMax; // 먼지 생성 영역 - 최대 지점
float3 worldBoundsMin; // 월드 제한 영역 - 최소 지점
float3 worldBoundsMax; // 월드 제한 영역 - 최대 지점
float deltaTime;

/* Controller */
float3 controllerPos;     // 월드 위치
float3 controllerForward; // 전방 벡터

/* Physics(Update) */
float3 gravity;      // 중력 가속도
float radius;        // 먼지 반지름
float mass;          // 질량
float airResistance; // 공기 저항력
float elasticity;    // 탄성력

/* Vacuum Cleaner */
float cleanerSqrDist;       // 먼지 흡입 범위(반지름) - 제곱
float cleanerSqrDeathRange; // 먼지 소멸 범위(반지름) - 제곱
float cleanerSqrForce;      // 빨아들이는 힘 - 제곱
float cleanerDotThreshold;  // 진공 청소기 원뿔 영역 내적 범위

/* Emitter */
float time;            // Time.time
float emitterForce;    // 방출 강도
float emitterDist;     // 방출 거리
float emitterAngleRad; // 방출 각도
uint emissionPerSec;   // 초당 먼지 발사 개수
float4x4 controllerMatrix; //  localToWorld

/* Blower */
float blowerSqrDist;       // 영향 범위(반지름) - 제곱
float blowerSqrForce;      // 미는 힘 - 제곱
float blowerDotThreshold;  // 원뿔 영역 내적 범위

/*******************************************************************
/*                            Functions
/*******************************************************************/
// 먼지 파괴
void DestroyDust(uint i)
{
    dustBuffer[i].isAlive = FALSE;
    InterlockedAdd(aliveNumberBuffer[0], -1);
}

/*******************************************************************
/*                             Kernels
/*******************************************************************/
// 0 - 초기 생성
[NUM_THREADS_HEADER]
void Populate (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    
    float width = spawnBoundsMax.x - spawnBoundsMin.x;
    float seed = i / (width * width * 179.823);

    dustBuffer[i].position = RandomRange13(seed, spawnBoundsMin, spawnBoundsMax);
    dustBuffer[i].isAlive = TRUE;
}

// 1 - 실시간 업데이트(물리)
[NUM_THREADS_HEADER]
void Update (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == FALSE) return;
    if(i >= dustCount) return;

    float3 A = 0; // 가속도 합 벡터
    
    // F = m * a
    // v = a * t

    // ===================================================
    //                    속도 계산
    // ===================================================
    //A += F / mass;

    // [1] 중력
    A += gravity;

    // [2] 공기 저항
    A -= velocityBuffer[i] * airResistance;

    // 속도 적용 : V = A * t
    velocityBuffer[i] += A * deltaTime;
    
    // ===================================================
    //              이동 시뮬레이션, 충돌 검사
    // ===================================================
    // 다음 프레임 위치 계산 : S = S0 + V * t
    float3 currPos = dustBuffer[i].position;
    float3 nextPos = currPos + velocityBuffer[i] * deltaTime;

    // [1] 월드 영역 제한(Cube)
    Bounds bounds;
    bounds.min = worldBoundsMin;
    bounds.max = worldBoundsMax;
    ConfineWithinCubeBounds(currPos, nextPos, velocityBuffer[i], radius, elasticity, bounds);

    // [2] Sphere to Sphere
    //float3 spherePos = float3(0, 2.5, 0);
    //float3 sphereRadius = 5;
    //bool sphereCollided = CheckSphereToSphereCollision(nextPos, radius, spherePos, sphereRadius);
    //if(sphereCollided)
    //{
    //    float3 inDir = normalize(velocityBuffer[i]);
    //    float3 contactNormal = normalize(nextPos - spherePos);
    //    float3 adjNextPos = spherePos + contactNormal * (sphereRadius + radius);
    //    float3 outDir = reflect(inDir, contactNormal);
    //
    //    nextPos = adjNextPos;
    //    velocityBuffer[i] = outDir * length(velocityBuffer[i]) * 0.8;
    //}
    
    // 다음 위치 적용
    dustBuffer[i].position = nextPos;
}

// 2 - 진공 청소기로 빨아들이기
[NUM_THREADS_HEADER]
void VacuumUp (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == FALSE) return;
    if(i >= dustCount) return;

    float3 F = 0; // 힘 합 벡터
    bool flag = false;

    float3 currPos = dustBuffer[i].position;       // 현재 프레임 먼지 위치
    float3 currToHead = (controllerPos - currPos); // 먼지 -> 청소기 입구
    float sqrDist = SqrMagnitude(currToHead);      // 청소기 입구 <-> 먼지 사이 거리 제곱

    // 원뿔 범위 및 힘 계산
    if (sqrDist < cleanerSqrDist)
    {
        float3 dustToHeadDir = normalize(currToHead); // 먼지 -> 청소기 입구 방향
        float dotValue = dot(controllerForward, -dustToHeadDir);

        // 원뿔 범위 내에 있을 경우 빨아들이기
        if(dotValue > cleanerDotThreshold)
        {
            float force = cleanerSqrForce / sqrDist;

            // 빨아들이는 힘
            F += dustToHeadDir * force * dotValue;

            flag = true;
        }
    }

    // 속도 계산
    if(flag)
    {
        // 가속도
        float3 A = F / mass;

        // 속도
        velocityBuffer[i] += A * deltaTime;

        // 다음 프레임 위치 예측 : S = S0 + V * t
        float3 nextPos = currPos + velocityBuffer[i] * deltaTime;

        float3 headToNext = nextPos - controllerPos;
        float3 headToCurrDir = normalize(-currToHead);
        float3 headToNextDir = normalize(headToNext);

        // 현재 프레임에 먼지가 원뿔 범위 내에 있었다면
        if(dot(controllerForward, headToCurrDir) > cleanerDotThreshold)
        {
            // 다음 프레임에 원뿔 밖으로 나가거나 입구에 근접하면 파괴
            if(dot(controllerForward, headToNextDir) < cleanerDotThreshold ||
                SqrMagnitude(headToNext) < cleanerSqrDeathRange)
            {
                DestroyDust(i);
            }
        }
    }
}

// 3 - 죽었던 먼지들 살려서 발사
[NUM_THREADS_HEADER]
void Emit (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == TRUE) return;
    if(i >= dustCount) return;

    /* 발사 확률 계산*/
    // emissionPerSec = 프레임당 발사되는 개수 / deltaTime
    // 발사 확률 = 프레임당 발사되는 개수 / 현재 개수

    float aliveCount = dustCount - aliveNumberBuffer[0]; // 죽은(발사 가능한) 먼지 개수
    float emissionCount = emissionPerSec * deltaTime;    // 발사할 먼지 개수
    float emissionRatio = emissionCount / aliveCount;    // 발사 확률

    float seed = (i + time) / 79238.288;
    float r = Random11(seed);
    if(r > emissionRatio) return;

    // Note : localDir의 z를 1로 고정하고, xy를 tan(emitterAngleRad)로 지정함으로써
    // 발사되는 먼지들이 형성하는 원뿔의 각도를 suctionAngle로 설정하는 효과를 얻는다.
    
    // r2.x : 각 먼지의 각도 (-360 ~ 360), r2.y : 원의 반지름(원뿔의 각도 결정)
    float seed2 = i / 82801.277;
    float2 r2 = RandomRange12(seed2, float2(-TAU, 0), float2(TAU, 1));
    float2 randomCircle = float2(cos(r2.x), sin(r2.x)) * r2.y * tan(emitterAngleRad);
    
    // 발사 방향 벡터 공간 변환
    float3 localDir = float3(randomCircle.x, randomCircle.y, 1);
    float3 worldDir = mul(controllerMatrix, float4(localDir, 0)).xyz;
    
    float3 F = worldDir * emitterForce * emitterDist;
    float3 A = F / mass;
    float3 V = A * deltaTime;

    dustBuffer[i].position = controllerPos;
    velocityBuffer[i] = V;

    // 먼지 되살리기
    dustBuffer[i].isAlive = TRUE;
    InterlockedAdd(aliveNumberBuffer[0], 1);
}

// 4 - 바람 불기
[NUM_THREADS_HEADER]
void BlowWind (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(dustBuffer[i].isAlive == FALSE) return;
    if(i >= dustCount) return;

    float3 dustPos = dustBuffer[i].position;        // 현재 프레임 먼지 위치
    float3 headToDust = (dustPos - controllerPos);  // 입구 -> 먼지
    float sqrDist = SqrMagnitude(headToDust);       // 입구<-> 먼지 사이 거리 제곱

    // 구형 범위 내에 포함되는 경우
    if (sqrDist < blowerSqrDist)
    {
        float3 headToDustDir = normalize(headToDust); // 입구 -> 먼지 방향
        float dotValue = dot(controllerForward, headToDustDir);

        // 원뿔 범위 내에 포함되는 경우, 밀쳐내기
        if(dotValue > blowerDotThreshold)
        {
            float force = blowerSqrForce / sqrt(sqrDist);

            float3 F = headToDustDir * force * dotValue;
            float3 A = F / mass;
            velocityBuffer[i] += A * deltaTime;
        }
    }
}